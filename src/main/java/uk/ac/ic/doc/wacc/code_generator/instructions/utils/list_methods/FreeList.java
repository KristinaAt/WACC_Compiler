package uk.ac.ic.doc.wacc.code_generator.instructions.utils.list_methods;import uk.ac.ic.doc.wacc.code_generator.instructions.basics.BranchInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.basics.Label;import uk.ac.ic.doc.wacc.code_generator.instructions.expression_instructions.CMPInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.memory_instructions.LDRInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.memory_instructions.MOVInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.memory_instructions.POPInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.memory_instructions.PUSHInstruction;import uk.ac.ic.doc.wacc.code_generator.instructions.operands.ConstantOffset;import uk.ac.ic.doc.wacc.code_generator.instructions.operands.OffsetRegister;import uk.ac.ic.doc.wacc.code_generator.instructions.utils.AbstractUtilMethod;import static uk.ac.ic.doc.wacc.code_generator.instructions.basics.BranchInstruction.Branch.BL;import static uk.ac.ic.doc.wacc.code_generator.instructions.basics.BranchInstruction.Branch.BNE;import static uk.ac.ic.doc.wacc.code_generator.instructions.memory_instructions.ElementSize.WORD;import static uk.ac.ic.doc.wacc.code_generator.instructions.operands.Register.Identifier.*;import static uk.ac.ic.doc.wacc.code_generator.instructions.utils.UtilMethodLabel.*;public class FreeList extends AbstractUtilMethod {    public FreeList(Label firstLabel, Label secondLabel) {        super();        /* Generates the free list label followed by the assembly           code for freeing a list */        this.instructions.add(new Label(p_free_list.toString()));        this.instructions.add(new PUSHInstruction(LR.getRegister()));        /* Remembers the next node after the head node, before freeing the           head node. PUSH and POP to prevent register corruption. */        this.instructions.add(new LDRInstruction(r1.getRegister(),                OffsetRegister.preIndexedOffset(r0.getRegister(),                        new ConstantOffset(4)), WORD));        this.instructions.add(new PUSHInstruction(r1.getRegister()));        this.instructions.add(new BranchInstruction(BL, new Label("free")));        this.instructions.add(new POPInstruction(r1.getRegister()));        /* While loop branching. Jumps to condition */        this.instructions.add(new BranchInstruction(BL, secondLabel));        /* Body of while loop - Remember the next node and then free the           current node stored inside of r1. */        this.instructions.add(firstLabel);        this.instructions.add(new MOVInstruction(r0.getRegister(), r1.getRegister()));        this.instructions.add(new LDRInstruction(r1.getRegister(),                OffsetRegister.preIndexedOffset(r1.getRegister(),                        new ConstantOffset(4)), WORD));        this.instructions.add(new PUSHInstruction(r1.getRegister()));        this.instructions.add(new BranchInstruction(BL, new Label("free")));        this.instructions.add(new POPInstruction(r1.getRegister()));        /* Condition: If the next node is null then we are complete, otherwise           we loop. */        this.instructions.add(secondLabel);        this.instructions.add(new CMPInstruction(r1.getRegister(), new ConstantOffset(0)));        this.instructions.add(new BranchInstruction(BNE, firstLabel));        /* Pops the program counted off the stack */        this.instructions.add(new POPInstruction(PC.getRegister()));    }}